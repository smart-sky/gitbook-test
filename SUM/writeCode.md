#代码的规范

>这里主要参照了阿里的「阿里巴巴Java开发手册」，https://www.cnblogs.com/renyuanwei/p/9169452.html

##命名规约


##命名原则


##类的命名

>1.1.6 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾

>1.1.14 枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开

>1.1.11 如果使用到了设计模式，建议在类名中体现出具体模式

##常量规约
>1.2.1 不允许出现任何魔法值（即未经定义的常量）直接出现在代码中

>1.2.5 如果变量值仅在一个范围内变化用Enum类。如果还带有名称之外的延伸属性，必须使用Enum类

#语法糖

>1.4.5 不能使用过时的类或方法

>1.4.10 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败

>1.4.17 循环体内，字符串的联接方式，使用StringBuilder的append

#方法命名


>1.1.15  Service/DAO层方法命名规约
 - 获取单个对象的方法用get做前缀
 - 获取多个对象的方法用list做前缀
 - 获取统计值的方法用count做前缀
 - 插入的方法用save（推荐）或insert做前缀
 - 删除的方法用remove（推荐）或delete做前缀
 - 修改的方法用update做前缀

#方法和属性
>1.4.9 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值

>1.4.11 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中

>1.4.15 类内方法定义顺序依次是：公有方法或保护方法 > 私有方法 > getter/setter方法

#格式规约

>1.3 6. 单行字符数限不超过 120 个

#并发处理
>1.6.1 获取单例对象需要保证线程安全，其中的方法也要保证线程安全

>1.6.2 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯

>1.6.3 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程

>1.6.4 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor去创建

>1.6.5 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁

>1.6.7 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁

>1.6.8 并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据

#数据库规约

>3.1.5 唯一索引名为uk_字段名；普通索引名则为idx_字段名

>明确日期和时间，日期使用date类型并使用xxDate进行Java字段命名，时间使用date_time类型并使用xxTime进行Java字段命名，以示区分


>3.1.9 表必备三字段：id, gmt_create, gmt_modified

>3.1.8 如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率

>3.1.13 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况

>3.1.14 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表

>3.2.5 如果有order by的场景，请注意利用索引的有序性

>3.3.1 不要使用count(列名)或count(常量)来替代count(*)

>3.3.5 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句

>3.3.6 不得使用外键与级联，一切外键概念必须在应用层解决

>3.3.7 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性

>3.3.9 in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内

#代码风格

>1.7.3 如果非得使用if()...else if()...else...方式表达逻辑，【强制】请勿超过3层，超过请使用状态设计模式

>在业务逻辑中尽可能不要使用setter方法，而是使用构造函数或者封装成一个有逻辑意义的方法，提高代码的可读性


































